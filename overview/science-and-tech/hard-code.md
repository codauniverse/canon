# Hard Code

## Overview

<figure><img src="../../.gitbook/assets/hardcode.png" alt="" width="563"><figcaption></figcaption></figure>

Hard code modules are compiled "physical functions". Hard code is the only legal form of computational system in [GATA](../../nations/gata/) and [NDA](../../nations/gata/politics/the-new-dawn-accords.md)-compliant states.

Hard-coded systems are impervious to corruption because their functions are physically encoded in the shape and structure of its computational components called ‘modules’. They cannot be re-written remotely or compelled to perform functions that it was not designed with the capacity to perform.

By their nature, hard-coded systems are much larger than general purpose precursors.

The most common programming language for writing hard code is [LMNL](hard-code.md#lmnl).

***

## LMNL

Liminal (LMNL) is an [Asimov-complete](asimovian-architecture.md) hard-code programming language used to write physical functions. LMNL being Asimov-complete means that by simply writing hard-code in LMNL, systems will be safe and secure in accordance with [New Dawn Accord](../../nations/gata/politics/the-new-dawn-accords.md) standards and regulations that prohibit general purpose processors.&#x20;

Hard-coded systems are similar in principal to the Application-Specific Integrated Circuits (ASICs) found in legacy technology; hardware that is designed and optimized for a single purpose. Code written in LMNL compiles to corresponding hard code; physical computational structures fabricated in carbon and silicon. Most Asimovian systems today use hard-coded modules written in LMNL.

### Usage & Usability

LMNL has been especially critical for the creation of filter modules. LMNL provides a framework for programmers to more easily codify rules that filter, throttle and direct information within a computational system. By physically restricting the kinds of logical structures that can be compiled, LMNL ensures that systems process information in a “safe cascade”. This has the effect of limiting how a system can access and manipulate information–aka [ontology design](asimovian-architecture.md#ontology-design). One of its most prominent effects is that it dramatically limits the adaptability, or creativity of [cogs](cogs.md)—an intentional feature that has advantages and drawbacks.

Compiled LMNL modules can be compiled as a pre-assembled program, or existing modules can be assembled into complete programs. While module assembly and shell fabrication can be automated, some programmers prefer to assemble their LMNL modules and shells by hand.

### **Standard LMNL Formats**

Standard formats with standardized dimensions and port locations. LMNL modules are suspended inside a polymer nanocomposite to fill out the volume of the standard format, making LMNL modules easy to compose into larger programs.

* Sticks: 10cm x 0.7cm x 0.7cm
* Spikes: 2cm diameter cylinders for most consumer programs
* Cards: 5cm x 8cm x 0.7cm
* Cartridges: For most enterprise applications, 16cm x 12cm x 1.5cm
* Bricks: chunky cartridges, measuring 20cm x 12cm x 6cm, with enough room for most System subroutines
* Blocks: Large blocks, measuring 20cm x 24cm x 24cm, with enough room for most enterprise-level cog programs.

Of course, LMNL can be used to write physical functions of any shape and size–particularly relevant for large, complex systems with many filter modules. The hard code required to run a large office building’s various systems could easily compile to large enough modules that it would require an entire floor to house them.

LMNL templates and module plans can be purchased on the market, and prices can vary widely. Bootleg templates and modules can be found on the black market, and are more commonly seen in [Grey Zones](../../nations/gata/politics/gray-zones.md), the [Free Territories](../../nations/free-territories/), [URSA](../../nations/ursa/) and [New Imperial Japan](../../nations/new-imperial-japan/).
