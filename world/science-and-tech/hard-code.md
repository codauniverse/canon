---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Hard Code

<figure><img src="../../.gitbook/assets/nomoney420_close_up_insert_shot_of_small_interlocking_and_int_f1d52ece-29de-4f35-a36f-041d1eca9199_2.png" alt=""><figcaption><p>A close-up of a LMNL program with interlocking hard code modules. </p></figcaption></figure>

## Overview

Hard code modules are made of "physical functions"; logical circuits defined by their physical structure, that can be composed and extended to form secure, application-specific physical programs. Hard code is the only legal form of computational system in [GATA](../gata/) and [NDA](../gata/politics/new-dawn-accords.md)-compliant states.

Hard-coded systems are impervious to corruption because their functions are physically encoded in the shape and structure of its computational components, meaning they cannot be re-written remotely or compelled to perform functions that they were not designed with the capacity to perform.

By their nature, hard-coded systems are much larger than their general-purpose precursors. This is because each logical function must be physically represented by a computational structure that performs only that function, and all information moving through the system must pass through relatively many redundant filter modules that are themselves written in hard code.

Today, the most common programming language for writing hard code is [LMNL](hard-code.md#lmnl), an open-source framework widely adopted around the world.

***

## Raw Hard Code

<figure><img src="../../.gitbook/assets/rawcode.png" alt="" width="563"><figcaption><p>An extremely compact system built with raw hard code.</p></figcaption></figure>

Less commonly utilized today, raw hard code refers to physical functions that are not written or compiled using frameworks or automation. Raw hard code is instead meticulously hand-constructed by master coders, allowing them to build more sophisticated and compact physical functions.

Prior to the popularization of LMNL, all hard-coded systems were built in this way. Hand-building physical functions allows much more flexibility in the shape of logical structures, and more efficient connections between its modules.

Most significantly, raw hard code allows the coder to funnel all data through a single filter module, rather than having many redundant filter modules distributed throughout the system, resulting in a dramatically more compact module or program.

However, using raw hard code comes at a cost; it is not Asimov-complete by default, unlike frameworks like LMNL, making it much more risky and expensive to build and maintain. Due to these dangers, raw hard code is only allowed to be produced and maintained by licensed enterprises and operators.

***

## LMNL

<figure><img src="../../.gitbook/assets/hardcode.png" alt="" width="563"><figcaption><p>A compiled LMNL module.</p></figcaption></figure>

LMNL (pronounced "liminal") is an [Asimov-complete](asimovian-architecture.md) hard-code programming language used to write physical functions. LMNL being Asimov-complete means that by simply writing hard-code in LMNL, systems will be safe and secure in accordance with [New Dawn Accord](../gata/politics/new-dawn-accords.md) standards and regulations that prohibit general purpose processors.

Hard-coded systems are similar in principal to the Application-Specific Integrated Circuits (ASICs) found in legacy technology; hardware components that are designed and optimized for a single purpose. Code written in LMNL compiles to corresponding hard code modules; physical computational structures fabricated in carbon and silicon. Most Asimovian systems today use hard-coded modules written in LMNL.

### Usage & Usability

By physically restricting the kinds of logical structures that can be compiled, LMNL ensures that systems process information in a “safe cascade”. This has the effect of limiting how a system can access and manipulate information–aka [ontology design](asimovian-architecture.md#ontology-design). One of its most prominent effects is that it dramatically limits the adaptability, or creativity of [cogs](cogs.md)—an intentional feature that has advantages and drawbacks.

LMNL has been especially critical for the standardization and proliferation of filter modules. LMNL provides a framework for programmers to more easily codify rules that filter, throttle and direct information within a computational system.

<figure><img src="../../.gitbook/assets/hardcode-j3093s.png" alt="" width="375"><figcaption><p>A hand-assembled program using a mix of pre-compiled and fabricated components.</p></figcaption></figure>

LMNL programs can be compiled as one complete module, or smaller fragmented modules that can then be combined into larger composite programs. The process of assembling modules into a composite program is called "hand compiling". Some hand-compilation is always necessary when a program integrates non-LMNL components. While compilation and shell fabrication can be automated, some coders simply prefer to assemble their LMNL programs and shells by hand.

The most ubiquitous LMNL programs are simple every day conveniences like data sticks and slips. However, LMNL can be used to write hard-coded systems of any shape and size–particularly useful for large, complex systems with many filter modules. The hard code required to run a large enterprise’s various systems often compile to modules large enough that they require entire rooms or standalone facilities to house them.

### **Standard Hard Code Formats**

<div data-full-width="true">

<figure><img src="../../.gitbook/assets/hardcode-3482k.png" alt=""><figcaption></figcaption></figure>

 

<figure><img src="../../.gitbook/assets/nomoney420_small_interlocking_and_interconnecting_modules_combi_87f8e77c-0458-420e-b220-b34fc220c6ab.png" alt=""><figcaption></figcaption></figure>

 

<figure><img src="../../.gitbook/assets/nomoney420_small_interlocking_and_interconnecting_modules_com_46c58c0b-d5f1-4b54-aede-f64821749f5c_1.png" alt=""><figcaption></figcaption></figure>

 

<figure><img src="../../.gitbook/assets/nomoney420_small_interlocking_and_interconnecting_modules_combi_c09d0252-a309-416c-852a-ee535a0f8b9d.png" alt=""><figcaption></figcaption></figure>

</div>

Over the years a variety of standard formats with standardized dimensions and port locations have emerged. The actual logical structures of compiled hard code are suspended inside a polymer nanocomposite that fills out the volume of the standard formats, making hard code modules easy to compose together, or plug into existing systems.

* Sticks: Small sticks commonly used for data storage. (10cm x 0.7cm x 0.7cm)
* Spikes: Pocket-sized wedges for most consumer programs. (2cm x 2cm x 6cm)
* Cards: Pocket-sized cards commonly used for ID and [commerce](../gata/politics/money.md). (5cm x 8cm x 0.7cm)
* Cartridges: Suitable for most enterprise applications. (16cm x 12cm x 1.5cm)
* Bricks: Chunkier cartridges with enough room for most System subroutines. (20cm x 12cm x 6cm)&#x20;
* Blocks: Large blocks with enough room for most enterprise-level COG programs. (20cm x 24cm x 24cm)

LMNL templates and module plans can be purchased on the market, and prices can vary widely. Bootleg templates and modules can be found on the black market, and are more commonly seen in [Grey Zones](../gata/politics/gray-zones.md), the [Free Territories](../free-territories/), [URSA](../ursa/) and [New Imperial Japan](../new-imperial-japan/).
