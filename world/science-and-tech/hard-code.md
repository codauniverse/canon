---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Hard Code

<figure><img src="../../.gitbook/assets/nomoney420_close_up_insert_shot_of_small_interlocking_and_int_f1d52ece-29de-4f35-a36f-041d1eca9199_2.png" alt=""><figcaption><p>A close-up of a LMNL program with interlocking hard code modules. </p></figcaption></figure>

## Overview

Hard code modules are compiled "physical functions". Hard code is the only legal form of computational system in [GATA](../gata/) and [NDA](../gata/politics/new-dawn-accords.md)-compliant states.

Hard-coded systems are impervious to corruption because their functions are physically encoded in the shape and structure of its computational components called ‘modules’. They cannot be re-written remotely or compelled to perform functions that they were not designed with the capacity to perform.

By their nature, hard-coded systems are much larger than general purpose precursors.

The most common programming language for writing hard code is [LMNL](hard-code.md#lmnl).

***

<figure><img src="../../.gitbook/assets/hardcode.png" alt="" width="563"><figcaption><p>A compiled LMNL module.</p></figcaption></figure>

## LMNL

Liminal (LMNL) is an [Asimov-complete](asimovian-architecture.md) hard-code programming language used to write physical functions. LMNL being Asimov-complete means that by simply writing hard-code in LMNL, systems will be safe and secure in accordance with [New Dawn Accord](../gata/politics/new-dawn-accords.md) standards and regulations that prohibit general purpose processors.&#x20;

Hard-coded systems are similar in principal to the Application-Specific Integrated Circuits (ASICs) found in legacy technology; hardware components that are designed and optimized for a single purpose. Code written in LMNL compiles to corresponding hard code; physical computational structures fabricated in carbon and silicon. Most Asimovian systems today use hard-coded modules written in LMNL.

### Usage & Usability

LMNL has been especially critical for the creation of filter modules. LMNL provides a framework for programmers to more easily codify rules that filter, throttle and direct information within a computational system. By physically restricting the kinds of logical structures that can be compiled, LMNL ensures that systems process information in a “safe cascade”. This has the effect of limiting how a system can access and manipulate information–aka [ontology design](asimovian-architecture.md#ontology-design). One of its most prominent effects is that it dramatically limits the adaptability, or creativity of [cogs](cogs.md)—an intentional feature that has advantages and drawbacks.

<figure><img src="../../.gitbook/assets/hardcode-j3093s.png" alt="" width="375"><figcaption><p>A hand-assembled program using a mix of pre-compiled and fabricated components.</p></figcaption></figure>

LMNL programs can be compiled as one large module, or smaller modules can be individually compiled and combined into complete programs. Some assembly is necessary when a program integrates non-LMNL components. While program assembly and shell fabrication can be automated, some programmers prefer to assemble their LMNL programs and shells by hand.

The most ubiquitous LMNL programs are simple every day conveniences like data sticks and slips.

### **Standard Hard Code Formats**

<div data-full-width="true">

<figure><img src="../../.gitbook/assets/hardcode-3482k.png" alt=""><figcaption></figcaption></figure>

 

<figure><img src="../../.gitbook/assets/nomoney420_small_interlocking_and_interconnecting_modules_combi_87f8e77c-0458-420e-b220-b34fc220c6ab.png" alt=""><figcaption></figcaption></figure>

 

<figure><img src="../../.gitbook/assets/nomoney420_small_interlocking_and_interconnecting_modules_com_46c58c0b-d5f1-4b54-aede-f64821749f5c_1.png" alt=""><figcaption></figcaption></figure>

 

<figure><img src="../../.gitbook/assets/nomoney420_small_interlocking_and_interconnecting_modules_combi_c09d0252-a309-416c-852a-ee535a0f8b9d.png" alt=""><figcaption></figcaption></figure>

</div>

Standard formats with standardized dimensions and port locations. Hard code modules are suspended inside a polymer nanocomposite to fill out the volume of the standard formats, making hard code modules easy to compose into larger programs.

* Sticks: 10cm x 0.7cm x 0.7cm
* Spikes: 2cm diameter cylinders for most consumer programs
* Cards: 5cm x 8cm x 0.7cm
* Cartridges: For most enterprise applications, 16cm x 12cm x 1.5cm
* Bricks: chunky cartridges, measuring 20cm x 12cm x 6cm, with enough room for most System subroutines
* Blocks: Large blocks, measuring 20cm x 24cm x 24cm, with enough room for most enterprise-level cog programs.

LMNL can be used to write hard coded physical functions of any shape and size–particularly relevant for large, complex systems with many filter modules. The hard code required to run a large enterprise’s various systems could easily compile to large enough modules that it would require an entire floor to house them.

LMNL templates and module plans can be purchased on the market, and prices can vary widely. Bootleg templates and modules can be found on the black market, and are more commonly seen in [Grey Zones](../gata/politics/gray-zones.md), the [Free Territories](../free-territories/), [URSA](../ursa/) and [New Imperial Japan](../new-imperial-japan/).
